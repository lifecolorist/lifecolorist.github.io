<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[零宽断言]]></title>
    <url>%2Fposts%2F17457%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 主题优化]]></title>
    <url>%2Fposts%2F42368%2F</url>
    <content type="text"><![CDATA[优化项 主页头像切换为圆形 页面顶部增加阅读进度 参考链接Hexo 主题美化Hexo Next主题设置和优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[c++容器迭代器失效分析]]></title>
    <url>%2Fposts%2F3244%2F</url>
    <content type="text"><![CDATA[什么情况算失效当迭代器指向的元素与插入或删除操作之前的元素不同时，就认为该迭代器失效。具体的原因有两种: 由于插入/删除操作做成容器内存重新分配 原有的迭代器指向了与操作之前不同的元素 指针和引用指向的都是某个内存位置的元素，所以当原来指向的内存位置的值发生变化，就会失效 vector首先分析一下 vector 的迭代器：1234567template &lt;typename T,typename Alloc=alloc&gt;class vector &#123;public: typedef T value_type; typedef value_type* iterator;...&#125;; 由此可以知道，vector 的迭代器就是指针如果插入后内存发生重新分配，则所有的迭代器、引用和指针都失效。如果内存没有重新分配，则： 插入/删除操作后，插入点之前的元素并不受影响，所以其迭代器，引用和指针仍然有效 插入点之后的元素位置发生变化，所以插入点之后元素的迭代器，引用和指针都会失效 插入/删除元素后，尾后迭代器失效 list1234567891011121314151617181920template&lt;class T,class Ref,class Ptr&gt;struct __list_iterator &#123;... typedef __list_node&lt;T&gt;* link_type;...&#125;;template &lt;typename T,typename Alloc=alloc&gt;class list &#123;protected: typedef __list_node&lt;T&gt; list_node;public: typedef list_node* link_type; iterator begin() &#123;return (link_type)((*node).next); &#125; iterator end() &#123;return node;&#125; protected: link_type node;...&#125;; 除了插入/删除点之外，容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍然有效 deque12345678910template &lt;typename T,typename Alloc=alloc&gt;struct __deque_iterator &#123;... typedef T** map_pointer; T* cur; T* first; T* last; map_pointer node;&#125;; 插入 插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效 —— 插入会导致插入点之前或插入点之后的元素发生移动，根据插入点之前的元素个数和插入点之后的元素个数来确定移动之前还是之后的元素 如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效 —— 因为插入可能导致重新分配 map，迭代器发生变化 删除： 首尾位置之外的任何位置删除元素都会导致迭代器、指针和引用失效。—— 根据删除点之前和之后的元素个数不同移动之前或之后的元素 如果删除尾元素，则尾后迭代器失效，但其他迭代器、引用和指针不受影响；如果删除首元素，则其他迭代器、引用和指针也不受影响。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己编写more]]></title>
    <url>%2Fposts%2F27287%2F</url>
    <content type="text"><![CDATA[more命令可以实现的功能是很丰富的，包括模式查找。今天我们只是实现它的一个基本功能： more 文件列表 在屏幕正文显示已读的百分比 按下回车显示下一行 按下空格显示下一屏 按下q退出 按回车、空格、q时没有回显 这里有几个问题： 要在屏幕正文显示已读的百分比，那我们必须先获取文件列表中各个文件的长度，这个可以使用系统调用lstat 12345678910111213141516 #include&lt;sys/stat.h&gt; struct stat *buf; lstat("filename",buf) //获取文件状态 filesize+=buf-&gt;st_size; //获取文件大小 ``` 2. 要显示整屏内容，我们就需要知道一屏可以显示多少行，然后从文件中读出这么多行显示在屏幕上。 ```c #include&lt;termios.h&gt; struct winsize *ws; ws=(struct winsize*)malloc(sizeof(struct winsize)); memset(ws,0x00,sizeof(struct winsize)); ioctl(STDIN_FILENO,TIOCGWINSZ,ws); int width=ws-&gt;ws_col; int height=ws-&gt;ws_row; 禁用回显 12345#include&lt;termios.h&gt;struct termios ts; //终端属性tcgetattr(STDIN_FILENO,&amp;ts); //获取终端属性 ts.c_lflag &amp;= (~ECHO); //阻止回显tcsetattr(STDIN_FILENO,TCSAFLUSH,&amp;ts); //设置终端的新属性 备注：如果要开启回显，可以用ts.c_lflag |= ECHO; 从终端读取单个字符后立即返回，不需要按回车 1234567#include&lt;termios.h&gt;struct termios ts; //终端属性tcgetattr(STDIN_FILENO,&amp;ts); //获取终端属性 ts.c_lflag &amp;= (~ICANON); //设置终端为非标准模式，在非标准模式下终端驱动程序没有缓冲区，输入立即交换程序处理ts.c_cc[VMIN]=1; //VMIN的值告诉驱动程序一次可以读取多少个字符。如果想一次读取3个字符就设为3ts.c_cc[VTIME]=0; //VTIME设置超时tcsetattr(STDIN_FILENO,TCSAFLUSH,&amp;ts); //设置终端的新属性 通过管道传递参数，必须将输入与键盘输入分开 通过 /dev/tty 读取键盘输入 备注：终端有三种模式： 规范模式：驱动程序输入的字符保存在缓冲区中，仅在接收到Enter键后才发送给程序，在此之前支持对输入的编辑。 非规范模式：没有缓冲区，输入一个字母就立即交给程序。 raw模式：每个处理步骤都被一个独立的位控制。例如，ISIG位控制Ctrl-C键是否用于终止一个程序。程序可以随意地关闭这些处理步骤。 默认情况下打开的文件都处于阻塞模式，当调用getchar()时如果用户一直不输入，程序就会一直等待。使用fcntl或open文件时可以为文件描述符指定非阻塞模式O_NDELAY或O_NONBLOCK。关闭文件描述符的阻塞状态并调用read，如果没有输入字符，read就返回0。 终端驱动程序不仅是一行一行地缓冲输入，而且是一行一行有缓冲输出。可以调用fflush(stdout)强制缓冲输出。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;stdio.h&gt;#include&lt;sys/ioctl.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;termios.h&gt;void gettermsize(int *w,int *h); //获取终端尺寸void do_more(FILE *); //根据see_more获取的用户输入，显示更多的文件内容或退出int see_more(); //捕获用户的输入指令void settermattr(); //设置终端属性int width; //终端屏幕宽度int height; //终端屏幕高度int filesize; //文件的大小int readsize; //已经显示的内容长度struct termios ts,ots; //终端属性int main(int argc,char *argv[])&#123; gettermsize(&amp;width,&amp;height); settermattr(); FILE *fp; struct stat *buf; filesize=0; readsize=0; buf=(struct stat*)malloc(sizeof(struct stat)); memset(buf,0x00,sizeof(struct stat)); if(argc==1) //如果没有指定文件，则从标准输入读取内容 do_more(stdin); else&#123; //从文件列表中读取内容 int i; for(i=1;i&lt;argc;i++)&#123; //more命令后面可能跟多个文件 if((fp=fopen(*(argv+i),"r"))!=0)&#123; //以只读形式打开文件 if(lstat((const char*)*(argv+i),buf)==0)&#123; //获取文件状态 filesize+=buf-&gt;st_size; //获取文件大小 printf("fs=%lld\n",buf-&gt;st_size); &#125; else&#123; exit(1); &#125; fclose(fp); //关闭文件 &#125; else&#123; //打开文件失败,退出程序 exit(1); &#125; &#125; printf("size=%d\n",filesize); for(i=1;i&lt;argc;i++)&#123; //more命令后面可能跟多个文件 if((fp=fopen(*(argv+i),"r"))!=0)&#123; //以只读形式打开文件 do_more(fp); //显示文件内容 fclose(fp); //关闭文件 &#125; else&#123; //打开文件失败,退出程序 exit(1); &#125; &#125; &#125; tcsetattr(STDIN_FILENO,TCSANOW,&amp;ots); return 0;&#125;void gettermsize(int *w,int *h)&#123; struct winsize *ws; ws=(struct winsize*)malloc(sizeof(struct winsize)); memset(ws,0x00,sizeof(struct winsize)); ioctl(STDIN_FILENO,TIOCGWINSZ,ws); *w=ws-&gt;ws_col; *h=ws-&gt;ws_row;&#125;void settermattr()&#123; tcgetattr(STDIN_FILENO,&amp;ts); //获取终端属性 ots=ts; //备份终端属性 ts.c_lflag &amp;= (~ECHO); //阻止回显 ts.c_lflag &amp;= (~ICANON); //设置终端为非标准模式 ts.c_cc[VMIN]=1; //这两行当需要从终端获取字符时立即返回，不需要按回车键 ts.c_cc[VTIME]=0; tcsetattr(STDIN_FILENO,TCSAFLUSH,&amp;ts); //设置终端的新属性。TCSAFLUSH表示输出队列空了以后才生效，生效之前的输出队列被flush&#125;void do_more(FILE *fp)&#123; int linesize=width; char line[linesize]; int num_of_lines=0; //记录本次读了多少行 int reply; //记录see_more()的返回值 FILE *fp_tty; fp_tty=fopen("/dev/tty","r"); if(fp_tty==NULL) exit(1); while(fgets(line,linesize,fp))&#123; //从文件中读取一行内容 readsize+=strlen(line); //读出的内容长度 if(num_of_lines==height)&#123; //如果满屏了 reply=see_more(); //从键盘获取用户输入的命令 if(reply==0)&#123; //用户不需要显示更多内容了，要退出 tcsetattr(STDIN_FILENO,TCSANOW,&amp;ots); exit(0); &#125; num_of_lines-=reply; &#125; if(fputs(line,stdout)==EOF)&#123; //把这行内容显示在用户屏幕上 tcsetattr(STDIN_FILENO,TCSANOW,&amp;ots); //TCSANOW表示修改立即生效 perror("fputs"); exit(1); &#125; num_of_lines++; &#125;&#125;int see_more()&#123; int c; printf("\n\033[s"); printf("\033[7m--more--(%2.0f%%)\033[m",(double)readsize/filesize*100); while((c=getc(stdin))!=EOF)&#123; //注意加括号，赋值操作符是右结合的。如果不加括号会把getchar()!=EOF的结果赋给c if(c=='q')&#123; return 0; &#125; if(c==' ') &#123; //空格 printf("\033[u\033[K\033[u"); return height; &#125; if(c=='\n') &#123; //回车 printf("\033[u\033[K\033[u"); return 1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
